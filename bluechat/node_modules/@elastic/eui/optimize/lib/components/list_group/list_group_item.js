"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SIZES = exports.EuiListGroupItem = exports.COLORS = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _react = _interopRequireWildcard(require("react"));
var _classnames = _interopRequireDefault(require("classnames"));
var _icon = require("../icon");
var _tool_tip = require("../tool_tip");
var _inner_text = require("../inner_text");
var _list_group_item_extra_action = require("./list_group_item_extra_action");
var _services = require("../../services");
var _clone_element = require("../../services/theme/clone_element");
var _href_validator = require("../../services/security/href_validator");
var _list_group_item = require("./list_group_item.styles");
var _react2 = require("@emotion/react");
var _excluded = ["label", "isActive", "isDisabled", "href", "target", "rel", "className", "css", "iconType", "icon", "iconProps", "extraAction", "onClick", "size", "color", "showToolTip", "wrapText", "buttonRef", "toolTipText"],
  _excluded2 = ["iconType", "alwaysShow", "isDisabled"];
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var SIZES = ['xs', 's', 'm', 'l'];
exports.SIZES = SIZES;
var COLORS = ['primary', 'text', 'subdued'];
exports.COLORS = COLORS;
var EuiListGroupItem = function EuiListGroupItem(_ref) {
  var label = _ref.label,
    _ref$isActive = _ref.isActive,
    isActive = _ref$isActive === void 0 ? false : _ref$isActive,
    _ref$isDisabled = _ref.isDisabled,
    _isDisabled = _ref$isDisabled === void 0 ? false : _ref$isDisabled,
    href = _ref.href,
    target = _ref.target,
    rel = _ref.rel,
    className = _ref.className,
    customCss = _ref.css,
    iconType = _ref.iconType,
    icon = _ref.icon,
    iconProps = _ref.iconProps,
    extraAction = _ref.extraAction,
    onClick = _ref.onClick,
    _ref$size = _ref.size,
    size = _ref$size === void 0 ? 'm' : _ref$size,
    _ref$color = _ref.color,
    color = _ref$color === void 0 ? 'text' : _ref$color,
    _ref$showToolTip = _ref.showToolTip,
    showToolTip = _ref$showToolTip === void 0 ? false : _ref$showToolTip,
    wrapText = _ref.wrapText,
    buttonRef = _ref.buttonRef,
    toolTipText = _ref.toolTipText,
    rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);
  var isClickable = !!(href || onClick);
  var isHrefValid = !href || (0, _href_validator.validateHref)(href);
  var isDisabled = _isDisabled || !isHrefValid;
  var euiTheme = (0, _services.useEuiTheme)();
  var iconStyles = (0, _list_group_item.euiListGroupItemIconStyles)(euiTheme);
  var cssIconStyles = [iconStyles.euiListGroupItem__icon];
  var iconNode;
  if (iconType) {
    iconNode = (0, _react2.jsx)(_icon.EuiIcon, (0, _extends2.default)({
      color: "inherit" // forces the icon to inherit its parent color
      ,
      css: cssIconStyles
    }, iconProps, {
      type: iconType,
      className: (0, _classnames.default)('euiListGroupItem__icon', iconProps === null || iconProps === void 0 ? void 0 : iconProps.className)
    }));
    if (icon) {
      console.warn('Both `iconType` and `icon` were passed to EuiListGroupItem but only one can exist. The `iconType` was used.');
    }
  } else if (icon) {
    iconNode = (0, _clone_element.cloneElementWithCss)(icon, {
      css: cssIconStyles,
      className: (0, _classnames.default)('euiListGroupItem__icon', icon.props.className)
    });
  }
  var extraActionNode;
  if (extraAction) {
    var _iconType = extraAction.iconType,
      alwaysShow = extraAction.alwaysShow,
      actionIsDisabled = extraAction.isDisabled,
      _rest = (0, _objectWithoutProperties2.default)(extraAction, _excluded2);

    // EuiListGroupItemExtraActionProps extends EuiButtonIconPropsForButton
    // which doesn't have the color `subdued` so we need to assign a valid color
    // the most similar is `text` so we'll use that
    var extraActionColor = color === 'subdued' ? 'text' : color;
    extraActionNode = (0, _react2.jsx)(_list_group_item_extra_action.EuiListGroupItemExtraAction, (0, _extends2.default)({
      color: extraActionColor,
      iconType: _iconType,
      alwaysShow: alwaysShow
    }, _rest, {
      isDisabled: actionIsDisabled,
      parentIsDisabled: isDisabled
    }));
  }
  var labelStyles = (0, _list_group_item.euiListGroupItemLabelStyles)();
  var cssLabelStyles = [labelStyles.euiListGroupItem__label, wrapText ? labelStyles.wrapText : labelStyles.truncate];

  // Only add the label as the title attribute if it's possibly truncated
  // Also ensure the value of the title attribute is a string
  var _useInnerText = (0, _inner_text.useInnerText)(),
    _useInnerText2 = (0, _slicedToArray2.default)(_useInnerText, 2),
    ref = _useInnerText2[0],
    innerText = _useInnerText2[1];
  var shouldRenderTitle = !wrapText && !showToolTip;
  var labelContent = shouldRenderTitle ? (0, _react2.jsx)("span", {
    ref: ref,
    className: "euiListGroupItem__label",
    css: cssLabelStyles,
    title: typeof label === 'string' ? label : innerText
  }, label) : (0, _react2.jsx)("span", {
    className: "euiListGroupItem__label",
    css: cssLabelStyles
  }, label);

  // Handle the variety of interaction behavior
  var itemContent;
  var innerStyles = (0, _list_group_item.euiListGroupItemInnerStyles)(euiTheme);
  var cssInnerStyles = [innerStyles.euiListGroupItem__inner, innerStyles[size], !isDisabled && innerStyles[color], isActive && innerStyles.isActive, isDisabled && innerStyles.isDisabled, isClickable && !isDisabled && innerStyles.isClickable];
  if (href && !isDisabled) {
    itemContent = (0, _react2.jsx)("a", (0, _extends2.default)({
      className: "euiListGroupItem__button",
      css: cssInnerStyles,
      href: href,
      target: target,
      rel: (0, _services.getSecureRelForTarget)({
        href: href,
        rel: rel,
        target: target
      }),
      onClick: onClick
    }, rest), iconNode, labelContent);
  } else if (href && isDisabled || onClick) {
    itemContent = (0, _react2.jsx)("button", (0, _extends2.default)({
      type: "button",
      className: "euiListGroupItem__button",
      css: cssInnerStyles,
      disabled: isDisabled,
      onClick: onClick,
      ref: buttonRef
    }, rest), iconNode, labelContent);
  } else {
    itemContent = (0, _react2.jsx)("span", (0, _extends2.default)({
      className: "euiListGroupItem__text",
      css: cssInnerStyles
    }, rest), iconNode, labelContent);
  }
  var styles = (0, _list_group_item.euiListGroupItemStyles)(euiTheme);
  var cssStyles = [styles.euiListGroupItem, !isDisabled && isActive && styles.colors.isActive[color], !isDisabled && isClickable && styles.colors.isClickable[color], styles[size], customCss];
  var classes = (0, _classnames.default)('euiListGroupItem', className);
  if (showToolTip) {
    var tooltipStyles = (0, _list_group_item.euiListGroupItemTooltipStyles)();
    var cssTooltipStyles = [tooltipStyles.euiListGroupItem__tooltip];
    itemContent = (0, _react2.jsx)("li", {
      className: classes,
      css: cssStyles
    }, (0, _react2.jsx)(_tool_tip.EuiToolTip, {
      anchorClassName: "euiListGroupItem__tooltip",
      anchorProps: {
        css: cssTooltipStyles
      },
      content: toolTipText !== null && toolTipText !== void 0 ? toolTipText : label,
      position: "right",
      delay: "long"
    }, itemContent));
  } else {
    itemContent = (0, _react2.jsx)("li", {
      className: classes,
      css: cssStyles
    }, itemContent, extraActionNode);
  }
  return (0, _react2.jsx)(_react.Fragment, null, itemContent);
};
exports.EuiListGroupItem = EuiListGroupItem;