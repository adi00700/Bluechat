"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EuiSelectableList = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _classnames = _interopRequireDefault(require("classnames"));
var _reactWindow = require("react-window");
var _auto_sizer = require("../../auto_sizer");
var _highlight = require("../../highlight");
var _selectable_list_item = require("./selectable_list_item");
var _react2 = require("@emotion/react");
var _excluded = ["data"],
  _excluded2 = ["label", "isGroupLabel", "checked", "disabled", "prepend", "append", "ref", "key", "searchableLabel", "data"],
  _excluded3 = ["className", "options", "searchValue", "onOptionClick", "renderOption", "height", "windowProps", "rowHeight", "activeOptionIndex", "makeOptionId", "showIcons", "singleSelection", "visibleOptions", "allowExclusions", "bordered", "paddingSize", "searchable", "onFocusBadge", "listId", "setActiveOptionIndex", "aria-label", "aria-labelledby", "aria-describedby", "role", "isVirtualized", "textWrap"];
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /*
                                                                                                                                                                                                                                                                                                                                           * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
                                                                                                                                                                                                                                                                                                                                           * or more contributor license agreements. Licensed under the Elastic License
                                                                                                                                                                                                                                                                                                                                           * 2.0 and the Server Side Public License, v 1; you may not use this file except
                                                                                                                                                                                                                                                                                                                                           * in compliance with, at your election, the Elastic License 2.0 or the Server
                                                                                                                                                                                                                                                                                                                                           * Side Public License, v 1.
                                                                                                                                                                                                                                                                                                                                           */ // Consumer Configurable Props via `EuiSelectable.listProps`
var EuiSelectableList = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(EuiSelectableList, _Component);
  var _super = _createSuper(EuiSelectableList);
  function EuiSelectableList(props) {
    var _this;
    (0, _classCallCheck2.default)(this, EuiSelectableList);
    _this = _super.call(this, props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "listRef", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "listBoxRef", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setListRef", function (ref) {
      _this.listRef = ref;
      if (ref && _this.props.activeOptionIndex) {
        ref.scrollToItem(_this.props.activeOptionIndex, 'auto');
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "removeScrollableTabStop", function (ref) {
      // Firefox adds a tab stop for scrollable containers
      // We handle this inside so need to stop firefox from doing its thing
      if (ref) {
        ref.setAttribute('tabindex', '-1');
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setListBoxRef", function (ref) {
      _this.listBoxRef = ref;
      var _this$props = _this.props,
        listId = _this$props.listId,
        searchable = _this$props.searchable,
        singleSelection = _this$props.singleSelection,
        ariaLabel = _this$props['aria-label'],
        ariaLabelledby = _this$props['aria-labelledby'],
        ariaDescribedby = _this$props['aria-describedby'];
      if (ref) {
        ref.setAttribute('id', listId);
        ref.setAttribute('role', 'listbox');
        if (searchable !== true) {
          ref.setAttribute('tabindex', '0');
          if (singleSelection !== 'always' && singleSelection !== true) {
            ref.setAttribute('aria-multiselectable', 'true');
          }
        }
        if (typeof ariaLabel === 'string') {
          ref.setAttribute('aria-label', ariaLabel);
        } else if (typeof ariaLabelledby === 'string') {
          ref.setAttribute('aria-labelledby', ariaLabelledby);
        }
        if (typeof ariaDescribedby === 'string') {
          ref.setAttribute('aria-describedby', ariaDescribedby);
        }
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "ariaSetSize", 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "ariaPosInSetMap", {});
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "calculateAriaSetAttrs", function (optionArray) {
      _this.ariaPosInSetMap = {};
      var latestAriaPosIndex = 0;
      optionArray.forEach(function (option, index) {
        if (!option.isGroupLabel) {
          latestAriaPosIndex++;
          _this.ariaPosInSetMap[index] = latestAriaPosIndex;
        }
      });
      _this.ariaSetSize = latestAriaPosIndex;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "ListRow", /*#__PURE__*/(0, _react.memo)(function (_ref) {
      var data = _ref.data,
        index = _ref.index,
        style = _ref.style;
      var option = data[index];
      var optionData = option.data,
        _option = (0, _objectWithoutProperties2.default)(option, _excluded);
      var label = option.label,
        isGroupLabel = option.isGroupLabel,
        checked = option.checked,
        disabled = option.disabled,
        prepend = option.prepend,
        append = option.append,
        ref = option.ref,
        key = option.key,
        searchableLabel = option.searchableLabel,
        _data = option.data,
        optionRest = (0, _objectWithoutProperties2.default)(option, _excluded2);
      var _this$props2 = _this.props,
        activeOptionIndex = _this$props2.activeOptionIndex,
        allowExclusions = _this$props2.allowExclusions,
        onFocusBadge = _this$props2.onFocusBadge,
        paddingSize = _this$props2.paddingSize,
        searchValue = _this$props2.searchValue,
        showIcons = _this$props2.showIcons,
        makeOptionId = _this$props2.makeOptionId,
        renderOption = _this$props2.renderOption,
        setActiveOptionIndex = _this$props2.setActiveOptionIndex,
        searchable = _this$props2.searchable,
        textWrap = _this$props2.textWrap;
      if (isGroupLabel) {
        return (0, _react2.jsx)("li", (0, _extends2.default)({
          role: "presentation",
          className: "euiSelectableList__groupLabel",
          style: style
          // @ts-ignore complex
        }, optionRest), prepend, label, append);
      }
      var id = makeOptionId(index);
      return (0, _react2.jsx)(_selectable_list_item.EuiSelectableListItem, (0, _extends2.default)({
        key: id,
        id: id,
        style: style,
        onMouseDown: function onMouseDown() {
          setActiveOptionIndex(index);
        },
        onClick: function onClick(event) {
          event.persist(); // NOTE: This is needed for React v16 backwards compatibility
          _this.onAddOrRemoveOption(option, event);
        },
        ref: ref ? ref.bind(null, index) : undefined,
        isFocused: activeOptionIndex === index,
        title: searchableLabel || label,
        checked: checked,
        disabled: disabled,
        prepend: prepend,
        append: append,
        "aria-posinset": _this.ariaPosInSetMap[index],
        "aria-setsize": _this.ariaSetSize,
        onFocusBadge: onFocusBadge,
        allowExclusions: allowExclusions,
        showIcons: showIcons,
        paddingSize: paddingSize,
        searchable: searchable,
        textWrap: textWrap
      }, optionRest), renderOption ? renderOption( // @ts-ignore complex
      _objectSpread(_objectSpread({}, _option), optionData), _this.props.searchValue) : (0, _react2.jsx)(_highlight.EuiHighlight, {
        search: searchValue
      }, label));
    }, _reactWindow.areEqual));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onAddOrRemoveOption", function (option, event) {
      if (option.disabled) {
        return;
      }
      var _this$props3 = _this.props,
        allowExclusions = _this$props3.allowExclusions,
        options = _this$props3.options,
        _this$props3$visibleO = _this$props3.visibleOptions,
        visibleOptions = _this$props3$visibleO === void 0 ? options : _this$props3$visibleO;
      _this.props.setActiveOptionIndex(visibleOptions.findIndex(function (_ref2) {
        var label = _ref2.label;
        return label === option.label;
      }), function () {
        if (option.checked === 'on' && allowExclusions) {
          _this.onExcludeOption(option, event);
        } else if (option.checked === 'on' || option.checked === 'off') {
          _this.onRemoveOption(option, event);
        } else {
          _this.onAddOption(option, event);
        }
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onAddOption", function (addedOption, event) {
      var _this$props4 = _this.props,
        onOptionClick = _this$props4.onOptionClick,
        options = _this$props4.options,
        singleSelection = _this$props4.singleSelection;
      var changedOption = _objectSpread({}, addedOption);
      var updatedOptions = options.map(function (option) {
        // if singleSelection is enabled, uncheck any selected option(s)
        var updatedOption = _objectSpread({}, option);
        if (singleSelection) {
          delete updatedOption.checked;
        }

        // if this is the now-selected option, check it
        if (option === addedOption) {
          updatedOption.checked = 'on';
          changedOption = updatedOption;
        }
        return updatedOption;
      });
      onOptionClick(updatedOptions, event, changedOption);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onRemoveOption", function (removedOption, event) {
      var _this$props5 = _this.props,
        onOptionClick = _this$props5.onOptionClick,
        singleSelection = _this$props5.singleSelection,
        options = _this$props5.options;
      var changedOption = _objectSpread({}, removedOption);
      var updatedOptions = options.map(function (option) {
        var updatedOption = _objectSpread({}, option);
        if (option === removedOption && singleSelection !== 'always') {
          delete updatedOption.checked;
          changedOption = updatedOption;
        }
        return updatedOption;
      });
      onOptionClick(updatedOptions, event, changedOption);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onExcludeOption", function (excludedOption, event) {
      var _this$props6 = _this.props,
        onOptionClick = _this$props6.onOptionClick,
        options = _this$props6.options;
      var changedOption = _objectSpread({}, excludedOption);
      var updatedOptions = options.map(function (option) {
        var updatedOption = _objectSpread({}, option);
        if (option === excludedOption) {
          updatedOption.checked = 'off';
          changedOption = updatedOption;
        }
        return updatedOption;
      });
      onOptionClick(updatedOptions, event, changedOption);
    });
    return _this;
  }
  (0, _createClass2.default)(EuiSelectableList, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var activeOptionIndex = this.props.activeOptionIndex;
      if (this.listBoxRef && this.props.searchable !== true) {
        this.listBoxRef.setAttribute('aria-activedescendant', "".concat(this.props.makeOptionId(activeOptionIndex)));
      }
      if (this.listRef && typeof this.props.activeOptionIndex !== 'undefined') {
        this.listRef.scrollToItem(this.props.activeOptionIndex, 'auto');
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props7 = this.props,
        className = _this$props7.className,
        options = _this$props7.options,
        searchValue = _this$props7.searchValue,
        onOptionClick = _this$props7.onOptionClick,
        renderOption = _this$props7.renderOption,
        forcedHeight = _this$props7.height,
        windowProps = _this$props7.windowProps,
        rowHeight = _this$props7.rowHeight,
        activeOptionIndex = _this$props7.activeOptionIndex,
        makeOptionId = _this$props7.makeOptionId,
        showIcons = _this$props7.showIcons,
        singleSelection = _this$props7.singleSelection,
        visibleOptions = _this$props7.visibleOptions,
        allowExclusions = _this$props7.allowExclusions,
        bordered = _this$props7.bordered,
        paddingSize = _this$props7.paddingSize,
        searchable = _this$props7.searchable,
        onFocusBadge = _this$props7.onFocusBadge,
        listId = _this$props7.listId,
        setActiveOptionIndex = _this$props7.setActiveOptionIndex,
        ariaLabel = _this$props7['aria-label'],
        ariaLabelledby = _this$props7['aria-labelledby'],
        ariaDescribedby = _this$props7['aria-describedby'],
        role = _this$props7.role,
        isVirtualized = _this$props7.isVirtualized,
        textWrap = _this$props7.textWrap,
        rest = (0, _objectWithoutProperties2.default)(_this$props7, _excluded3);
      var optionArray = visibleOptions || options;
      this.calculateAriaSetAttrs(optionArray);
      var heightIsFull = forcedHeight === 'full';
      var calculatedHeight = heightIsFull ? false : forcedHeight;

      // If calculatedHeight is still undefined, then calculate it
      if (calculatedHeight === undefined) {
        var maxVisibleOptions = 7;
        var numVisibleOptions = optionArray.length;
        var numVisibleMoreThanMax = optionArray.length > maxVisibleOptions;
        if (numVisibleMoreThanMax) {
          // Show only half of the last one to indicate there's more to scroll to
          calculatedHeight = (maxVisibleOptions - 0.5) * rowHeight;
        } else {
          calculatedHeight = numVisibleOptions * rowHeight;
        }
      }
      var classes = (0, _classnames.default)('euiSelectableList', {
        'euiSelectableList-fullHeight': heightIsFull,
        'euiSelectableList-bordered': bordered
      }, className);
      return (0, _react2.jsx)("div", (0, _extends2.default)({
        className: classes
      }, rest), isVirtualized ? (0, _react2.jsx)(_auto_sizer.EuiAutoSizer, {
        disableHeight: !heightIsFull
      }, function (_ref3) {
        var width = _ref3.width,
          height = _ref3.height;
        return (0, _react2.jsx)(_reactWindow.FixedSizeList, (0, _extends2.default)({
          ref: _this2.setListRef,
          outerRef: _this2.removeScrollableTabStop,
          className: "euiSelectableList__list",
          "data-skip-axe": "scrollable-region-focusable",
          width: width,
          height: calculatedHeight || height,
          itemCount: optionArray.length,
          itemData: optionArray,
          itemSize: rowHeight,
          innerElementType: "ul",
          innerRef: _this2.setListBoxRef
        }, windowProps), _this2.ListRow);
      }) : (0, _react2.jsx)("div", {
        className: "euiSelectableList__list",
        ref: this.removeScrollableTabStop
      }, (0, _react2.jsx)("ul", {
        ref: this.setListBoxRef
      }, optionArray.map(function (_, index) {
        return /*#__PURE__*/_react.default.createElement(_this2.ListRow, {
          key: index,
          data: optionArray,
          index: index
        }, null);
      }))));
    }
  }]);
  return EuiSelectableList;
}(_react.Component);
exports.EuiSelectableList = EuiSelectableList;
(0, _defineProperty2.default)(EuiSelectableList, "defaultProps", {
  rowHeight: 32,
  searchValue: '',
  isVirtualized: true
});
EuiSelectableList.propTypes = {
  className: _propTypes.default.string,
  "aria-label": _propTypes.default.string,
  "data-test-subj": _propTypes.default.string,
  css: _propTypes.default.any,
  /**
       * The index of the option to be highlighted as pseudo-focused;
       * Good for use when only one selection is allowed and needing to open
       * directly to that option
       */
  activeOptionIndex: _propTypes.default.number,
  /**
       * Show the check/cross selection indicator icons
       */
  showIcons: _propTypes.default.bool,
  singleSelection: _propTypes.default.oneOfType([_propTypes.default.oneOf(["always"]), _propTypes.default.bool.isRequired]),
  /**
       * Any props to send specifically to the react-window `FixedSizeList`
       */
  windowProps: _propTypes.default.any,
  /**
       * Adds a border around the list to indicate the bounds;
       * Useful when the list scrolls, otherwise use your own container
       */
  bordered: _propTypes.default.bool,
  /**
       * When enabled by setting to either `true` or passing custom text,
       * shows a hollow badge as an append (far right) when the item is focused.
       * The default content when `true` is `↩ to select/deselect/include/exclude`
       */
  onFocusBadge: _propTypes.default.oneOfType([_propTypes.default.bool.isRequired, _propTypes.default.shape({
    /**
       * Accepts any string from our icon library
       */
    iconType: _propTypes.default.oneOfType([_propTypes.default.oneOf(["accessibility", "addDataApp", "advancedSettingsApp", "agentApp", "aggregate", "analyzeEvent", "annotation", "apmApp", "apmTrace", "appSearchApp", "apps", "arrowDown", "arrowLeft", "arrowRight", "arrowUp", "arrowStart", "arrowEnd", "article", "asterisk", "auditbeatApp", "beaker", "bell", "bellSlash", "beta", "bolt", "boxesHorizontal", "boxesVertical", "branch", "branchUser", "broom", "brush", "bug", "bullseye", "calendar", "canvasApp", "casesApp", "check", "checkInCircleFilled", "cheer", "classificationJob", "clock", "cloudDrizzle", "cloudStormy", "cloudSunny", "cluster", "codeApp", "color", "compute", "console", "consoleApp", "container", "continuityAbove", "continuityAboveBelow", "continuityBelow", "continuityWithin", "controlsHorizontal", "controlsVertical", "copy", "copyClipboard", "createAdvancedJob", "createMultiMetricJob", "createPopulationJob", "createSingleMetricJob", "cross", "crossClusterReplicationApp", "crosshairs", "currency", "cut", "dashboardApp", "dataVisualizer", "database", "desktop", "devToolsApp", "discoverApp", "discuss", "document", "documentEdit", "documentation", "documents", "dot", "dotInCircle", "doubleArrowLeft", "doubleArrowRight", "download", "editorAlignCenter", "editorAlignLeft", "editorAlignRight", "editorBold", "editorChecklist", "editorCodeBlock", "editorComment", "editorDistributeHorizontal", "editorDistributeVertical", "editorHeading", "editorItalic", "editorItemAlignBottom", "editorItemAlignCenter", "editorItemAlignLeft", "editorItemAlignMiddle", "editorItemAlignRight", "editorItemAlignTop", "editorLink", "editorOrderedList", "editorPositionBottomLeft", "editorPositionBottomRight", "editorPositionTopLeft", "editorPositionTopRight", "editorRedo", "editorStrike", "editorTable", "editorUnderline", "editorUndo", "editorUnorderedList", "email", "empty", "emsApp", "eql", "eraser", "error", "exit", "expand", "expandMini", "exportAction", "eye", "eyeClosed", "faceHappy", "faceNeutral", "faceSad", "filebeatApp", "filter", "filterExclude", "filterIgnore", "filterInclude", "filterInCircle", "flag", "fleetApp", "fold", "folderCheck", "folderClosed", "folderExclamation", "folderOpen", "frameNext", "framePrevious", "fullScreen", "fullScreenExit", "function", "gear", "gisApp", "glasses", "globe", "grab", "grabHorizontal", "graphApp", "grid", "grokApp", "heart", "heartbeatApp", "heatmap", "help", "home", "iInCircle", "image", "importAction", "indexClose", "indexEdit", "indexFlush", "indexManagementApp", "indexMapping", "indexOpen", "indexPatternApp", "indexRollupApp", "indexRuntime", "indexSettings", "indexTemporary", "infinity", "inputOutput", "inspect", "invert", "ip", "keyboard", "kqlField", "kqlFunction", "kqlOperand", "kqlSelector", "kqlValue", "kubernetesNode", "kubernetesPod", "launch", "layers", "lensApp", "lettering", "lineDashed", "lineDotted", "lineSolid", "link", "list", "listAdd", "lock", "lockOpen", "logoAWS", "logoAWSMono", "logoAerospike", "logoApache", "logoAppSearch", "logoAzure", "logoAzureMono", "logoBeats", "logoBusinessAnalytics", "logoCeph", "logoCloud", "logoCloudEnterprise", "logoCode", "logoCodesandbox", "logoCouchbase", "logoDocker", "logoDropwizard", "logoElastic", "logoElasticStack", "logoElasticsearch", "logoEnterpriseSearch", "logoEtcd", "logoGCP", "logoGCPMono", "logoGithub", "logoGmail", "logoGolang", "logoGoogleG", "logoHAproxy", "logoIBM", "logoIBMMono", "logoKafka", "logoKibana", "logoKubernetes", "logoLogging", "logoLogstash", "logoMaps", "logoMemcached", "logoMetrics", "logoMongodb", "logoMySQL", "logoNginx", "logoObservability", "logoOsquery", "logoPhp", "logoPostgres", "logoPrometheus", "logoRabbitmq", "logoRedis", "logoSecurity", "logoSiteSearch", "logoSketch", "logoSlack", "logoUptime", "logoVulnerabilityManagement", "logoWebhook", "logoWindows", "logoWorkplaceSearch", "logsApp", "logstashFilter", "logstashIf", "logstashInput", "logstashOutput", "logstashQueue", "machineLearningApp", "magnet", "magnifyWithExclamation", "magnifyWithMinus", "magnifyWithPlus", "managementApp", "mapMarker", "memory", "menu", "menuDown", "menuLeft", "menuRight", "menuUp", "merge", "metricbeatApp", "metricsApp", "minimize", "minus", "minusInCircle", "minusInCircleFilled", "mobile", "monitoringApp", "moon", "namespace", "nested", "node", "notebookApp", "number", "offline", "online", "outlierDetectionJob", "package", "packetbeatApp", "pageSelect", "pagesSelect", "paperClip", "partial", "pause", "payment", "pencil", "percent", "pin", "pinFilled", "pipelineApp", "pivot", "play", "playFilled", "plus", "plusInCircle", "plusInCircleFilled", "popout", "push", "questionInCircle", "quote", "recentlyViewedApp", "refresh", "regressionJob", "reporter", "reportingApp", "returnKey", "save", "savedObjectsApp", "scale", "search", "searchProfilerApp", "securityAnalyticsApp", "securityApp", "securitySignal", "securitySignalDetected", "securitySignalResolved", "sessionViewer", "shard", "share", "snowflake", "sortAscending", "sortDescending", "sortDown", "sortLeft", "sortRight", "sortUp", "sortable", "spaces", "spacesApp", "sqlApp", "starEmpty", "starEmptySpace", "starFilled", "starFilledSpace", "starMinusEmpty", "starMinusFilled", "starPlusEmpty", "starPlusFilled", "stats", "stop", "stopFilled", "stopSlash", "storage", "string", "submodule", "sun", "swatchInput", "symlink", "tableDensityCompact", "tableDensityExpanded", "tableDensityNormal", "tableOfContents", "tag", "tear", "temperature", "timeline", "timelineWithArrow", "timelionApp", "timeRefresh", "timeslider", "training", "trash", "unfold", "unlink", "upgradeAssistantApp", "uptimeApp", "user", "userAvatar", "users", "usersRolesApp", "vector", "videoPlayer", "visArea", "visAreaStacked", "visBarHorizontal", "visBarHorizontalStacked", "visBarVertical", "visBarVerticalStacked", "visGauge", "visGoal", "visLine", "visMapCoordinate", "visMapRegion", "visMetric", "visPie", "visTable", "visTagCloud", "visText", "visTimelion", "visVega", "visVisualBuilder", "visualizeApp", "vulnerabilityManagementApp", "warning", "alert", "watchesApp", "wordWrap", "wordWrapDisabled", "workplaceSearchApp", "wrench", "tokenAlias", "tokenAnnotation", "tokenArray", "tokenBinary", "tokenBoolean", "tokenClass", "tokenCompletionSuggester", "tokenConstant", "tokenDate", "tokenDenseVector", "tokenElement", "tokenEnum", "tokenEnumMember", "tokenEvent", "tokenException", "tokenField", "tokenFile", "tokenFlattened", "tokenFunction", "tokenGeo", "tokenHistogram", "tokenInterface", "tokenIP", "tokenJoin", "tokenKey", "tokenKeyword", "tokenMethod", "tokenMetricCounter", "tokenMetricGauge", "tokenModule", "tokenNamespace", "tokenNested", "tokenNull", "tokenNumber", "tokenObject", "tokenOperator", "tokenPackage", "tokenParameter", "tokenPercolator", "tokenProperty", "tokenRange", "tokenRankFeature", "tokenRankFeatures", "tokenRepo", "tokenSearchType", "tokenShape", "tokenString", "tokenStruct", "tokenSymbol", "tokenTag", "tokenText", "tokenTokenCount", "tokenVariable"]).isRequired, _propTypes.default.string.isRequired, _propTypes.default.elementType.isRequired]),
    /**
       * The side of the badge the icon should sit
       */
    iconSide: _propTypes.default.any,
    /**
       * Accepts either our palette colors (primary, success ..etc) or a hex value `#FFFFFF`, `#000`.
       */
    color: _propTypes.default.oneOfType([_propTypes.default.any.isRequired, _propTypes.default.string.isRequired]),
    /**
       * Will override any color passed through the `color` prop.
       */
    isDisabled: _propTypes.default.bool,
    /**
       * Props passed to the close button.
       */
    closeButtonProps: _propTypes.default.any,
    className: _propTypes.default.string,
    "aria-label": _propTypes.default.string,
    "data-test-subj": _propTypes.default.string,
    css: _propTypes.default.any,
    /**
       * Will apply an onclick to icon within the badge
       */
    iconOnClick: _propTypes.default.func,
    /**
       * Aria label applied to the iconOnClick button
       */
    iconOnClickAriaLabel: _propTypes.default.any,
    /**
       * Will apply an onclick to the badge itself
       */
    onClick: _propTypes.default.func,
    /**
       * Aria label applied to the onClick button
       */
    onClickAriaLabel: _propTypes.default.any,
    href: _propTypes.default.string,
    target: _propTypes.default.string,
    rel: _propTypes.default.string
  }).isRequired]),
  /**
       * Padding for the list items.
       */
  paddingSize: _propTypes.default.any,
  /**
       * How to handle long text within the item.
       * Wrapping only works if virtualization is off.
       */
  textWrap: _propTypes.default.oneOf(["truncate", "wrap"]),
  /**
       * Use virtualized rendering for list items with `react-window`.
       * Sets each row's height to the value of `rowHeight`.
       */
  isVirtualized: _propTypes.default.oneOfType([_propTypes.default.oneOf([true]), _propTypes.default.oneOf([false]).isRequired]),
  /**
       *  The height of each option in pixels. Defaults to `32`.
       *  Has no effect if `isVirtualized=false`.
       */
  rowHeight: _propTypes.default.number,
  /**
     * All possible options
     */
  options: _propTypes.default.arrayOf(_propTypes.default.shape({
    /**
       * Optional `boolean`.
       * Set to `true` to indicate object is just a grouping label, not a selectable item
       */
    isGroupLabel: _propTypes.default.oneOfType([_propTypes.default.oneOf([true]).isRequired, _propTypes.default.oneOf([false])]),
    className: _propTypes.default.string,
    "aria-label": _propTypes.default.string,
    "data-test-subj": _propTypes.default.string,
    css: _propTypes.default.any,
    /**
       * Visible label of option.
       * Must be unique across items if `key` is not supplied
       */
    label: _propTypes.default.string,
    /**
       * Optionally change the searchable term by passing a different string other than the `label`.
       * Best used when creating a custom `optionRender` to separate the label from metadata but allowing to search on both
       */
    searchableLabel: _propTypes.default.string,
    /**
       * Must be unique across items.
       * Will be used to match options instead of `label`
       */
    key: _propTypes.default.string,
    /**
       * Leave `undefined` to indicate not selected. Pass a string of
       * 'on' to indicate inclusion, 'off' to indicate exclusion,
       * or 'mixed' to indicate inclusion for some.
       */
    checked: _propTypes.default.oneOf(["on", "off", "mixed", undefined]),
    disabled: _propTypes.default.bool,
    /**
       * Node to add between the selection icon and the label
       */
    prepend: _propTypes.default.node,
    /**
       * Node to add to the far right of the item
       */
    append: _propTypes.default.node,
    ref: _propTypes.default.func,
    /**
       * Option data to pass through to the `renderOptions` element.
       * Bypass `EuiSelectableItem` and avoid DOM attribute warnings.
       */
    data: _propTypes.default.shape({})
  }).isRequired).isRequired,
  /**
     * Filtered options list (if applicable)
     */
  visibleOptions: _propTypes.default.arrayOf(_propTypes.default.shape({
    isGroupLabel: _propTypes.default.oneOfType([_propTypes.default.oneOf([true]).isRequired, _propTypes.default.oneOf([false])]),
    className: _propTypes.default.string,
    "aria-label": _propTypes.default.string,
    "data-test-subj": _propTypes.default.string,
    css: _propTypes.default.any,
    label: _propTypes.default.string,
    searchableLabel: _propTypes.default.string,
    key: _propTypes.default.string,
    checked: _propTypes.default.oneOf(["on", "off", "mixed", undefined]),
    disabled: _propTypes.default.bool,
    prepend: _propTypes.default.node,
    append: _propTypes.default.node,
    ref: _propTypes.default.func,
    data: _propTypes.default.shape({})
  }).isRequired),
  /**
     * Search value to highlight on the option render
     */
  searchValue: _propTypes.default.string.isRequired,
  /**
     * Returns the array of options with altered checked state, the click/keyboard event,
     * and the option that triggered the click/keyboard event
     */
  onOptionClick: _propTypes.default.func.isRequired,
  /**
     * Custom render for the label portion of the option;
     * Takes (option, searchValue), returns ReactNode
     */
  renderOption: _propTypes.default.func,
  /**
     * Sets the max height in pixels or pass `full` to allow
     * the whole group to fill the height of its container and
     * allows the list grow as well
     */
  height: _propTypes.default.oneOfType([_propTypes.default.number.isRequired, _propTypes.default.oneOf(["full"])]),
  /**
     * Allow cycling through the on, off and undefined state of option.checked
     * and not just on and undefined
     */
  allowExclusions: _propTypes.default.bool,
  searchable: _propTypes.default.bool,
  makeOptionId: _propTypes.default.func.isRequired,
  listId: _propTypes.default.string.isRequired,
  setActiveOptionIndex: _propTypes.default.func.isRequired
};